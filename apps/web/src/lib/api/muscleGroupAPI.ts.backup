import axios, { AxiosResponse } from 'axios';
import { env } from '@/env';

// Available muscle groups from RapidAPI
export const MUSCLE_GROUPS = [
  'all',
  'all_lower',
  'all_upper',
  'abductors',
  'abs',
  'adductors',
  'back',
  'back_lower',
  'back_upper',
  'biceps',
  'calfs',
  'chest',
  'core',
  'core_lower',
  'core_upper',
  'forearms',
  'gluteus',
  'hamstring',
  'hands',
  'latissimus',
  'legs',
  'neck',
  'quadriceps',
  'shoulders',
  'shoulders_back',
  'shoulders_front',
  'triceps'
] as const;

export type MuscleGroup = typeof MUSCLE_GROUPS[number];

// API Response types
export interface MuscleGroupsResponse {
  muscleGroups: string[];
}

export interface ImageResponse {
  imageUrl: string;
  imageBase64?: string;
}

// API Request parameters
export interface SingleColorImageParams {
  muscleGroups: string; // comma-separated muscle groups
  color: string; // RGB format: "200,100,80"
  transparentBackground?: '0' | '1';
}

export interface MultiColorImageParams {
  primaryColor: string; // RGB format: "240,100,80"
  secondaryColor: string; // RGB format: "200,100,80"
  primaryMuscleGroups: string; // comma-separated
  secondaryMuscleGroups: string; // comma-separated
  transparentBackground?: '0' | '1';
}

export interface IndividualColorImageParams {
  muscleGroups: string; // comma-separated muscle groups
  colors: string; // comma-separated hex colors: "ff0000,0f0,00f"
  transparentBackground?: '0' | '1';
}

export interface BaseImageParams {
  transparentBackground?: '0' | '1';
}

// Error types
export class MuscleGroupAPIError extends Error {
  constructor(
    message: string,
    public statusCode?: number,
    public endpoint?: string
  ) {
    super(message);
    this.name = 'MuscleGroupAPIError';
  }
}

// Rate limiting and caching
interface CacheEntry {
  data: any;
  timestamp: number;
  expiresAt: number;
}

class APICache {
  private cache = new Map<string, CacheEntry>();
  private readonly DEFAULT_TTL = 60 * 60 * 1000; // 1 hour

  set(key: string, data: any, ttl: number = this.DEFAULT_TTL): void {
    const now = Date.now();
    this.cache.set(key, {
      data,
      timestamp: now,
      expiresAt: now + ttl
    });
  }

  get(key: string): any | null {
    const entry = this.cache.get(key);
    if (!entry) return null;

    if (Date.now() > entry.expiresAt) {
      this.cache.delete(key);
      return null;
    }

    return entry.data;
  }

  clear(): void {
    this.cache.clear();
  }

  size(): number {
    return this.cache.size;
  }
}

// Rate limiter
class RateLimiter {
  private requests: number[] = [];
  private readonly maxRequests: number;
  private readonly windowMs: number;

  constructor(maxRequests: number = 100, windowMs: number = 60000) {
    this.maxRequests = maxRequests;
    this.windowMs = windowMs;
  }

  async canMakeRequest(): Promise<boolean> {
    const now = Date.now();
    
    // Remove old requests outside the window
    this.requests = this.requests.filter(time => now - time < this.windowMs);
    
    return this.requests.length < this.maxRequests;
  }

  recordRequest(): void {
    this.requests.push(Date.now());
  }

  async waitForSlot(): Promise<void> {
    while (!(await this.canMakeRequest())) {
      await new Promise(resolve => setTimeout(resolve, 1000));
    }
  }
}

// Main API client
export class MuscleGroupAPI {
  private static instance: MuscleGroupAPI;
  private readonly baseURL = 'https://muscle-group-image-generator.p.rapidapi.com';
  private readonly cache = new APICache();
  private readonly rateLimiter = new RateLimiter(50, 60000); // 50 requests per minute
  
  private readonly headers = {
    'x-rapidapi-key': env.VITE_RAPIDAPI_KEY,
    'x-rapidapi-host': 'muscle-group-image-generator.p.rapidapi.com'
  };

  private constructor() {}

  static getInstance(): MuscleGroupAPI {
    if (!MuscleGroupAPI.instance) {
      MuscleGroupAPI.instance = new MuscleGroupAPI();
    }
    return MuscleGroupAPI.instance;
  }

  private async makeRequest<T>(
    endpoint: string, 
    params?: Record<string, any>,
    cacheTTL: number = 60 * 60 * 1000 // 1 hour default
  ): Promise<T> {
    // Create cache key
    const cacheKey = `${endpoint}:${JSON.stringify(params || {})}`;
    
    // Check cache first
    const cached = this.cache.get(cacheKey);
    if (cached) {
      return cached;
    }

    // Rate limiting
    await this.rateLimiter.waitForSlot();

    try {
      const response: AxiosResponse<T> = await axios.get(`${this.baseURL}${endpoint}`, {
        params,
        headers: this.headers,
        timeout: 30000, // 30 second timeout
      });

      this.rateLimiter.recordRequest();
      
      // Cache successful response
      this.cache.set(cacheKey, response.data, cacheTTL);
      
      return response.data;
    } catch (error) {
      if (axios.isAxiosError(error)) {
        const statusCode = error.response?.status;
        const message = error.response?.data?.message || error.message;
        
        throw new MuscleGroupAPIError(
          `API request failed: ${message}`,
          statusCode,
          endpoint
        );
      }
      
      throw new MuscleGroupAPIError(
        `Unknown error occurred: ${error}`,
        undefined,
        endpoint
      );
    }
  }

  /**
   * Get all available muscle groups
   */
  async getMuscleGroups(): Promise<MuscleGroupsResponse> {
    return this.makeRequest<MuscleGroupsResponse>('/getMuscleGroups', undefined, 24 * 60 * 60 * 1000); // Cache for 24 hours
  }

  /**
   * Generate single color muscle group image
   */
  async getSingleColorImage(params: SingleColorImageParams): Promise<ImageResponse> {
    this.validateMuscleGroups(params.muscleGroups);
    this.validateColor(params.color);
    
    return this.makeRequest<ImageResponse>('/getImage', {
      ...params,
      transparentBackground: params.transparentBackground || '0'
    });
  }

  /**
   * Generate dual color muscle group image (primary and secondary)
   */
  async getMultiColorImage(params: MultiColorImageParams): Promise<ImageResponse> {
    this.validateMuscleGroups(params.primaryMuscleGroups);
    this.validateMuscleGroups(params.secondaryMuscleGroups);
    this.validateColor(params.primaryColor);
    this.validateColor(params.secondaryColor);
    
    return this.makeRequest<ImageResponse>('/getMulticolorImage', {
      ...params,
      transparentBackground: params.transparentBackground || '0'
    });
  }

  /**
   * Generate individual color muscle group image (different color for each muscle)
   */
  async getIndividualColorImage(params: IndividualColorImageParams): Promise<ImageResponse> {
    this.validateMuscleGroups(params.muscleGroups);
    this.validateHexColors(params.colors);
    
    return this.makeRequest<ImageResponse>('/getIndividualColorImage', {
      ...params,
      transparentBackground: params.transparentBackground || '0'
    });
  }

  /**
   * Get base human body image without highlighted muscles
   */
  async getBaseImage(params: BaseImageParams = {}): Promise<ImageResponse> {
    return this.makeRequest<ImageResponse>('/getBaseImage', {
      transparentBackground: params.transparentBackground || '0'
    });
  }

  // Validation helpers
  private validateMuscleGroups(muscleGroups: string): void {
    const groups = muscleGroups.split(',').map(g => g.trim());
    const invalidGroups = groups.filter(group => !MUSCLE_GROUPS.includes(group as MuscleGroup));
    
    if (invalidGroups.length > 0) {
      throw new MuscleGroupAPIError(`Invalid muscle groups: ${invalidGroups.join(', ')}`);
    }
  }

  private validateColor(color: string): void {
    // Validate RGB format: "200,100,80"
    const rgbPattern = /^\d{1,3},\d{1,3},\d{1,3}$/;
    if (!rgbPattern.test(color)) {
      throw new MuscleGroupAPIError(`Invalid RGB color format: ${color}. Expected format: "200,100,80"`);
    }
    
    const [r, g, b] = color.split(',').map(Number);
    if (r > 255 || g > 255 || b > 255 || r < 0 || g < 0 || b < 0) {
      throw new MuscleGroupAPIError(`RGB values must be between 0-255: ${color}`);
    }
  }

  private validateHexColors(colors: string): void {
    const colorArray = colors.split(',').map(c => c.trim());
    const hexPattern = /^[0-9a-fA-F]{3}$|^[0-9a-fA-F]{6}$/;
    
    const invalidColors = colorArray.filter(color => !hexPattern.test(color));
    if (invalidColors.length > 0) {
      throw new MuscleGroupAPIError(`Invalid hex colors: ${invalidColors.join(', ')}`);
    }
  }

  // Utility methods
  getCacheStats() {
    return {
      size: this.cache.size(),
      rateLimitRequests: this.rateLimiter['requests'].length
    };
  }

  clearCache(): void {
    this.cache.clear();
  }
}

// Helper functions for common use cases
export const muscleGroupAPI = MuscleGroupAPI.getInstance();

/**
 * Convert exercise names to muscle groups for API calls
 */
export function exerciseToMuscleGroups(exerciseName: string): MuscleGroup[] {
  const exerciseMapping: Record<string, MuscleGroup[]> = {
    // Push exercises
    'push-up': ['chest', 'triceps', 'shoulders'],
    'bench-press': ['chest', 'triceps', 'shoulders'],
    'shoulder-press': ['shoulders', 'triceps'],
    'tricep-dips': ['triceps', 'chest'],
    
    // Pull exercises
    'pull-up': ['back', 'biceps'],
    'chin-up': ['biceps', 'back'],
    'rows': ['back', 'biceps'],
    'lat-pulldown': ['latissimus', 'biceps'],
    
    // Leg exercises
    'squat': ['quadriceps', 'gluteus'],
    'deadlift': ['hamstring', 'gluteus', 'back'],
    'lunges': ['quadriceps', 'gluteus'],
    'calf-raises': ['calfs'],
    
    // Core exercises
    'plank': ['abs', 'core'],
    'crunches': ['abs'],
    'sit-ups': ['abs', 'core'],
    
    // Full body
    'burpees': ['all'],
    'mountain-climbers': ['core', 'shoulders', 'legs'],
  };

  const normalized = exerciseName.toLowerCase().replace(/\s+/g, '-');
  return exerciseMapping[normalized] || ['all'];
}

/**
 * Generate workout visualization image
 */
export async function generateWorkoutImage(
  exercises: string[],
  primaryColor: string = '240,100,80',
  secondaryColor: string = '200,100,80'
): Promise<ImageResponse> {
  // Get all muscle groups from exercises
  const allMuscleGroups = exercises.flatMap(exerciseToMuscleGroups);
  
  // Count frequency to determine primary vs secondary
  const muscleCount = allMuscleGroups.reduce((acc, muscle) => {
    acc[muscle] = (acc[muscle] || 0) + 1;
    return acc;
  }, {} as Record<string, number>);
  
  // Sort by frequency
  const sortedMuscles = Object.entries(muscleCount)
    .sort(([,a], [,b]) => b - a)
    .map(([muscle]) => muscle);
  
  // Split into primary (top 3) and secondary (rest)
  const primaryMuscles = sortedMuscles.slice(0, 3);
  const secondaryMuscles = sortedMuscles.slice(3);
  
  if (primaryMuscles.length === 0) {
    return muscleGroupAPI.getBaseImage();
  }
  
  if (secondaryMuscles.length === 0) {
    return muscleGroupAPI.getSingleColorImage({
      muscleGroups: primaryMuscles.join(','),
      color: primaryColor
    });
  }
  
  return muscleGroupAPI.getMultiColorImage({
    primaryMuscleGroups: primaryMuscles.join(','),
    secondaryMuscleGroups: secondaryMuscles.join(','),
    primaryColor,
    secondaryColor
  });
} 